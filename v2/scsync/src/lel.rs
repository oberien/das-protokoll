use futures::{Future, Poll, Stream};

pub enum Lel<A, B, C, D, E, F, G, H, I, /*J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z*/> {
    A(A),
    B(B),
    C(C),
    D(D),
    E(E),
    F(F),
    G(G),
    H(H),
    I(I),
//    J(J),
//    K(K),
//    L(L),
//    M(M),
//    N(N),
//    O(O),
//    P(P),
//    Q(Q),
//    R(R),
//    S(S),
//    T(T),
//    U(U),
//    V(V),
//    W(W),
//    X(X),
//    Y(Y),
//    Z(Z),
}

use lel::Lel::*;

impl<A, B, C, D, E, F, G, H, I, /*J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,*/ Item, Err> Future for Lel<A, B, C, D, E, F, G, H, I, /*J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z*/>
where
    A: Future<Item = Item, Error = Err>,
    B: Future<Item = Item, Error = Err>,
    C: Future<Item = Item, Error = Err>,
    D: Future<Item = Item, Error = Err>,
    E: Future<Item = Item, Error = Err>,
    F: Future<Item = Item, Error = Err>,
    G: Future<Item = Item, Error = Err>,
    H: Future<Item = Item, Error = Err>,
    I: Future<Item = Item, Error = Err>,
//    J: Future<Item = Item, Error = Err>,
//    K: Future<Item = Item, Error = Err>,
//    L: Future<Item = Item, Error = Err>,
//    M: Future<Item = Item, Error = Err>,
//    N: Future<Item = Item, Error = Err>,
//    O: Future<Item = Item, Error = Err>,
//    P: Future<Item = Item, Error = Err>,
//    Q: Future<Item = Item, Error = Err>,
//    R: Future<Item = Item, Error = Err>,
//    S: Future<Item = Item, Error = Err>,
//    T: Future<Item = Item, Error = Err>,
//    U: Future<Item = Item, Error = Err>,
//    V: Future<Item = Item, Error = Err>,
//    W: Future<Item = Item, Error = Err>,
//    X: Future<Item = Item, Error = Err>,
//    Y: Future<Item = Item, Error = Err>,
//    Z: Future<Item = Item, Error = Err>,
{
    type Item = Item;
    type Error = Err;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self {
            A(f) => f.poll(),
            B(f) => f.poll(),
            C(f) => f.poll(),
            D(f) => f.poll(),
            E(f) => f.poll(),
            F(f) => f.poll(),
            G(f) => f.poll(),
            H(f) => f.poll(),
            I(f) => f.poll(),
//            J(f) => f.poll(),
//            K(f) => f.poll(),
//            L(f) => f.poll(),
//            M(f) => f.poll(),
//            N(f) => f.poll(),
//            O(f) => f.poll(),
//            P(f) => f.poll(),
//            Q(f) => f.poll(),
//            R(f) => f.poll(),
//            S(f) => f.poll(),
//            T(f) => f.poll(),
//            U(f) => f.poll(),
//            V(f) => f.poll(),
//            W(f) => f.poll(),
//            X(f) => f.poll(),
//            Y(f) => f.poll(),
//            Z(f) => f.poll(),
        }
    }
}

impl<A, B, C, D, E, F, G, H, I, /*J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,*/ Item, Err> Stream for Lel<A, B, C, D, E, F, G, H, I, /*J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z*/>
    where
        A: Stream<Item = Item, Error = Err>,
        B: Stream<Item = Item, Error = Err>,
        C: Stream<Item = Item, Error = Err>,
        D: Stream<Item = Item, Error = Err>,
        E: Stream<Item = Item, Error = Err>,
        F: Stream<Item = Item, Error = Err>,
        G: Stream<Item = Item, Error = Err>,
        H: Stream<Item = Item, Error = Err>,
        I: Stream<Item = Item, Error = Err>,
//        J: Stream<Item = Item, Error = Err>,
//        K: Stream<Item = Item, Error = Err>,
//        L: Stream<Item = Item, Error = Err>,
//        M: Stream<Item = Item, Error = Err>,
//        N: Stream<Item = Item, Error = Err>,
//        O: Stream<Item = Item, Error = Err>,
//        P: Stream<Item = Item, Error = Err>,
//        Q: Stream<Item = Item, Error = Err>,
//        R: Stream<Item = Item, Error = Err>,
//        S: Stream<Item = Item, Error = Err>,
//        T: Stream<Item = Item, Error = Err>,
//        U: Stream<Item = Item, Error = Err>,
//        V: Stream<Item = Item, Error = Err>,
//        W: Stream<Item = Item, Error = Err>,
//        X: Stream<Item = Item, Error = Err>,
//        Y: Stream<Item = Item, Error = Err>,
//        Z: Stream<Item = Item, Error = Err>,
{
    type Item = Item;
    type Error = Err;

    fn poll(&mut self) -> Poll<Option<Self::Item>, Self::Error> {
        match self {
            A(f) => f.poll(),
            B(f) => f.poll(),
            C(f) => f.poll(),
            D(f) => f.poll(),
            E(f) => f.poll(),
            F(f) => f.poll(),
            G(f) => f.poll(),
            H(f) => f.poll(),
            I(f) => f.poll(),
//            J(f) => f.poll(),
//            K(f) => f.poll(),
//            L(f) => f.poll(),
//            M(f) => f.poll(),
//            N(f) => f.poll(),
//            O(f) => f.poll(),
//            P(f) => f.poll(),
//            Q(f) => f.poll(),
//            R(f) => f.poll(),
//            S(f) => f.poll(),
//            T(f) => f.poll(),
//            U(f) => f.poll(),
//            V(f) => f.poll(),
//            W(f) => f.poll(),
//            X(f) => f.poll(),
//            Y(f) => f.poll(),
//            Z(f) => f.poll(),
        }
    }
}
